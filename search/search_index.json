{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Proxmoxer \u00b6 Proxmoxer is a wrapper around the APIs for Proxmox products. It was inspired by slumber, but it is dedicated only to Proxmox. It allows not only REST API use over HTTPS, but the same api over SSH. Like Proxmoxia , it dynamically creates attributes which responds to the attributes you've attempted to reach. Supported Services \u00b6 Below are the Proxmox services supported by this library. 1 PVE ( API Spec ) PMG ( API Spec ) PBS ( API Spec ) Supported Backends (Connection Methods) \u00b6 Below are the backends supported by this library. 1 HTTPS SSH (openssh) SSH (ssh_paramiko) View the Setup page for details on how to setup your environment for each backend. The names of the services and backends can be in any case as the library will standardize the case to what it requires. e.g. \"hTtpS\" is just as valid as \"https\" or \"HTTPS\". \u21a9 \u21a9","title":"Welcome to Proxmoxer"},{"location":"#welcome-to-proxmoxer","text":"Proxmoxer is a wrapper around the APIs for Proxmox products. It was inspired by slumber, but it is dedicated only to Proxmox. It allows not only REST API use over HTTPS, but the same api over SSH. Like Proxmoxia , it dynamically creates attributes which responds to the attributes you've attempted to reach.","title":"Welcome to Proxmoxer"},{"location":"#supported-services","text":"Below are the Proxmox services supported by this library. 1 PVE ( API Spec ) PMG ( API Spec ) PBS ( API Spec )","title":"Supported Services"},{"location":"#supported-backends","text":"Below are the backends supported by this library. 1 HTTPS SSH (openssh) SSH (ssh_paramiko) View the Setup page for details on how to setup your environment for each backend. The names of the services and backends can be in any case as the library will standardize the case to what it requires. e.g. \"hTtpS\" is just as valid as \"https\" or \"HTTPS\". \u21a9 \u21a9","title":"Supported Backends (Connection Methods)"},{"location":"basic_usage/","text":"Basic Usage \u00b6 Proxmoxer is easy to use. After importing the library and creating an instance, interacting with the Proxmox service is simple and follows the API documentation. Importing and Creating an Instance \u00b6 Example Data In the examples below (and in the rest of the documentation), placeholders are used for values which will be different between installations. Anything within <> is a value you will need to change for your environment. There may be some additional examples of what a command might look like with actual values. Any time <> will be used not as placeholders, a note like this will explain the usage for that case. To use Proxmoxer, the library must be imported and a ProxmoxerAPI instance created. This instance takes care of all the authentication, abstraction, and de-serialization of the API calls. from proxmoxer import ProxmoxAPI proxmox = ProxmoxAPI('<host_ip_or_domain>', user='<username>@<realm>', password='<password>', verify_ssl=False) verify_ssl Parameter If you have set up valid SSL certificates, you can remove the verify_ssl=False , but the default self-signed certificates will throw an error without verify_ssl=False . Switching Services or Backends \u00b6 This will default to connecting to a 'PVE' service using the https backend. To change these defaults, specify a service or backend parameter of a supported service and/or a supported backend . e.g. proxmox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', backend='openssh', service='pmg') Changing Ports \u00b6 Proxmoxer (when using the https backend) will use the default port for the selected service to connect to the service. If you need to connect on a different port, adding either the port=<port_number> parameter or adding :<port> to the host can be used. A port in the host will override the port parameter. Making API Calls \u00b6 There are two ways to build API requests: dotted notation and string notation. The format and benefits of each are presented below. Dotted Notation \u00b6 Dotted notation can be thought of as treating the API call as a collection of dicts. This means that you can specify the API endpoint in a pythonic manner and let proxmoxer take care of converting to what the Proxmox service requires. Lets say you want to see what users are available and what containers are on the \"example-node\" node and that prox is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users >>> prox.access.users.get() [{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}] To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc >>> prox.nodes(\"example-node\").lxc.get() [{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}] To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each. >>> # get the list of all the nodes available from the connected node >>> print(proxmox.nodes.get()) [{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}] >>> # use the list of nodes to iterate through each and print the containers and their status >>> for pve_node in proxmox.nodes.get(): ... print(\"{0}:\".format(pve_node['node'])) ... for container in proxmox.nodes(pve_node['node']).lxc.get(): ... print(\"\\t{0}. {1} => {2}\".format(container['vmid'], container['name'], container['status'])) ... example-node: 100. container-a => running 101. container-b => running 105. container-c => running String Notation \u00b6 String notation allows the developer to specify the exact URL path to be used for the API call. This puts more responsibility on the developer to correctly format the path but gives ultimate configurability. The dotted notation examples are displayed below converted into string notation. Lets say you want to see what users are available and what containers are on the \"example-node\" node and that prox is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users >>> prox(\"access/users\").get() [{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}] To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc >>> prox(\"nodes/example-node/lxc\").get() [{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}] To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each. >>> # get the list of all the nodes available from the connected node >>> print(proxmox(\"nodes\").get()) [{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}] >>> # use the list of nodes to iterate through each and print the containers and their status >>> for pve_node in proxmox.nodes.get(): ... print(\"{0}:\".format(pve_node['node'])) ... for container in proxmox(\"nodes/{0}/lxc\".format(pve_node['node'])).get(): ... print(\"\\t{0}. {1} => {2}\".format(container['vmid'], container['name'], container['status'])) ... example-node: 100. container-a => running 101. container-b => running 105. container-c => running Combining Dotted and String Notation \u00b6 There are a few situations where combining the notations is required or more effective. Variable Data \u00b6 As mentioned in the Dotted Notation section, there are times when string notation is needed in combination with dotted notation. Invalid Names In Python \u00b6 Some endpoints in the Proxmox APIs include a hyphen (\"-\"). When using dotted notation, python interprets this as subtraction rather than a hyphen in the name. In this case, string notation can be used for that section of the path and using dotted notation for the rest of the path. For example, if you want to check the status of a command running in a VM, you would need to do the following >>> # using https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/qemu/{vmid}/agent/exec-status >>> prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec\").post(command=\"echo hello\") {'pid': 5413} >>> prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec-status\").get(pid=5413) {'out-data': 'hello\\n', 'exited': 1, 'exitcode': 0} Examples \u00b6 The following are all different ways of calling the same API path and will return the same result. prox.nodes(<node_name>).lxc.get() prox.nodes(<node_name>).get('lxc') prox.get('nodes/%s/lxc' % <node_name>) prox.get('nodes', <node_name>, 'lxc') prox('nodes')(<node_name>).lxc.get() prox(['nodes', <node_name>]).lxc.get() prox(['nodes', <node_name>]).get('lxc') prox('nodes')(<node_name>)('lxc').get()","title":"Basic Usage"},{"location":"basic_usage/#basic-usage","text":"Proxmoxer is easy to use. After importing the library and creating an instance, interacting with the Proxmox service is simple and follows the API documentation.","title":"Basic Usage"},{"location":"basic_usage/#importing-and-creating-an-instance","text":"Example Data In the examples below (and in the rest of the documentation), placeholders are used for values which will be different between installations. Anything within <> is a value you will need to change for your environment. There may be some additional examples of what a command might look like with actual values. Any time <> will be used not as placeholders, a note like this will explain the usage for that case. To use Proxmoxer, the library must be imported and a ProxmoxerAPI instance created. This instance takes care of all the authentication, abstraction, and de-serialization of the API calls. from proxmoxer import ProxmoxAPI proxmox = ProxmoxAPI('<host_ip_or_domain>', user='<username>@<realm>', password='<password>', verify_ssl=False) verify_ssl Parameter If you have set up valid SSL certificates, you can remove the verify_ssl=False , but the default self-signed certificates will throw an error without verify_ssl=False .","title":"Importing and Creating an Instance"},{"location":"basic_usage/#switching-services-or-backends","text":"This will default to connecting to a 'PVE' service using the https backend. To change these defaults, specify a service or backend parameter of a supported service and/or a supported backend . e.g. proxmox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', backend='openssh', service='pmg')","title":"Switching Services or Backends"},{"location":"basic_usage/#changing-ports","text":"Proxmoxer (when using the https backend) will use the default port for the selected service to connect to the service. If you need to connect on a different port, adding either the port=<port_number> parameter or adding :<port> to the host can be used. A port in the host will override the port parameter.","title":"Changing Ports"},{"location":"basic_usage/#making-api-calls","text":"There are two ways to build API requests: dotted notation and string notation. The format and benefits of each are presented below.","title":"Making API Calls"},{"location":"basic_usage/#dotted-notation","text":"Dotted notation can be thought of as treating the API call as a collection of dicts. This means that you can specify the API endpoint in a pythonic manner and let proxmoxer take care of converting to what the Proxmox service requires. Lets say you want to see what users are available and what containers are on the \"example-node\" node and that prox is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users >>> prox.access.users.get() [{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}] To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc >>> prox.nodes(\"example-node\").lxc.get() [{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}] To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each. >>> # get the list of all the nodes available from the connected node >>> print(proxmox.nodes.get()) [{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}] >>> # use the list of nodes to iterate through each and print the containers and their status >>> for pve_node in proxmox.nodes.get(): ... print(\"{0}:\".format(pve_node['node'])) ... for container in proxmox.nodes(pve_node['node']).lxc.get(): ... print(\"\\t{0}. {1} => {2}\".format(container['vmid'], container['name'], container['status'])) ... example-node: 100. container-a => running 101. container-b => running 105. container-c => running","title":"Dotted Notation"},{"location":"basic_usage/#string-notation","text":"String notation allows the developer to specify the exact URL path to be used for the API call. This puts more responsibility on the developer to correctly format the path but gives ultimate configurability. The dotted notation examples are displayed below converted into string notation. Lets say you want to see what users are available and what containers are on the \"example-node\" node and that prox is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users >>> prox(\"access/users\").get() [{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}] To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc >>> prox(\"nodes/example-node/lxc\").get() [{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}] To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each. >>> # get the list of all the nodes available from the connected node >>> print(proxmox(\"nodes\").get()) [{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}] >>> # use the list of nodes to iterate through each and print the containers and their status >>> for pve_node in proxmox.nodes.get(): ... print(\"{0}:\".format(pve_node['node'])) ... for container in proxmox(\"nodes/{0}/lxc\".format(pve_node['node'])).get(): ... print(\"\\t{0}. {1} => {2}\".format(container['vmid'], container['name'], container['status'])) ... example-node: 100. container-a => running 101. container-b => running 105. container-c => running","title":"String Notation"},{"location":"basic_usage/#combining-dotted-and-string-notation","text":"There are a few situations where combining the notations is required or more effective.","title":"Combining Dotted and String Notation"},{"location":"basic_usage/#variable-data","text":"As mentioned in the Dotted Notation section, there are times when string notation is needed in combination with dotted notation.","title":"Variable Data"},{"location":"basic_usage/#invalid-names-in-python","text":"Some endpoints in the Proxmox APIs include a hyphen (\"-\"). When using dotted notation, python interprets this as subtraction rather than a hyphen in the name. In this case, string notation can be used for that section of the path and using dotted notation for the rest of the path. For example, if you want to check the status of a command running in a VM, you would need to do the following >>> # using https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/qemu/{vmid}/agent/exec-status >>> prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec\").post(command=\"echo hello\") {'pid': 5413} >>> prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec-status\").get(pid=5413) {'out-data': 'hello\\n', 'exited': 1, 'exitcode': 0}","title":"Invalid Names In Python"},{"location":"basic_usage/#examples","text":"The following are all different ways of calling the same API path and will return the same result. prox.nodes(<node_name>).lxc.get() prox.nodes(<node_name>).get('lxc') prox.get('nodes/%s/lxc' % <node_name>) prox.get('nodes', <node_name>, 'lxc') prox('nodes')(<node_name>).lxc.get() prox(['nodes', <node_name>]).lxc.get() prox(['nodes', <node_name>]).get('lxc') prox('nodes')(<node_name>)('lxc').get()","title":"Examples"},{"location":"development/","text":"Development \u00b6 Stub Page This page may be incomplete or contain partial information. Please help improve this page by clicking the edit button above and submitting a Pull Request (PR) to expand this page. Installing from Source \u00b6 Sometimes there are features that have not been added to a published version in PyPI but are in the development source code in Git. You can install directly from the source code branches to test these features or develop more on them. Stability not guaranteed Installing from source control (Git) branches is inherently less stable than installing from PyPI. Installing like this will also not update when new versions or commits are published. Code in source control may be incomplete or broken. No support will be given for issues that arise from installing in this way, however bug reports of broken code are appreciated. There are two main branches to install from: master This branch is what the PyPI version are built from This branch should be as stable as the PyPI versions, so installing from here is unnecessary develop This branch contains the improvements and new features which will be bundled into a future version This branch should be mostly stable, but can have bugs which are removed before moved to a version Installing from this branch allows using the latest features and bug testing them To install from source control, use git+https://github.com/proxmoxer/proxmoxer.git@<branch> . You will most likely need to specify the -U ( --upgrade ) flag to overwrite the existing version with the source control version. For example: pip install --upgrade git+https://github.com/proxmoxer/proxmoxer.git@develop More information from installing from source control can be found in the VCS Support pip documentation.","title":"Development"},{"location":"development/#development","text":"Stub Page This page may be incomplete or contain partial information. Please help improve this page by clicking the edit button above and submitting a Pull Request (PR) to expand this page.","title":"Development"},{"location":"development/#installing-from-source","text":"Sometimes there are features that have not been added to a published version in PyPI but are in the development source code in Git. You can install directly from the source code branches to test these features or develop more on them. Stability not guaranteed Installing from source control (Git) branches is inherently less stable than installing from PyPI. Installing like this will also not update when new versions or commits are published. Code in source control may be incomplete or broken. No support will be given for issues that arise from installing in this way, however bug reports of broken code are appreciated. There are two main branches to install from: master This branch is what the PyPI version are built from This branch should be as stable as the PyPI versions, so installing from here is unnecessary develop This branch contains the improvements and new features which will be bundled into a future version This branch should be mostly stable, but can have bugs which are removed before moved to a version Installing from this branch allows using the latest features and bug testing them To install from source control, use git+https://github.com/proxmoxer/proxmoxer.git@<branch> . You will most likely need to specify the -U ( --upgrade ) flag to overwrite the existing version with the source control version. For example: pip install --upgrade git+https://github.com/proxmoxer/proxmoxer.git@develop More information from installing from source control can be found in the VCS Support pip documentation.","title":"Installing from Source"},{"location":"setup/","text":"Setup \u00b6 Proxmoxer is easy to setup and has minimal dependencies. Choosing a Backend \u00b6 The required dependencies change depending on the backend (connection method) you will use. The HTTPS backend better matches the details in the Proxmox API documentation, but SSH can be used in an (mostly) interchangeable manner. SSH can be used with complex network environments and can be used with jump hosts. The HTTPS backend can be used through a reverse proxy or any other HTTPS manipulation scheme. For most users, the HTTPS backend will be suitable. The HTTPS backend allows connections for non-PAM realm accounts and supports advanced authentication methods such as API Tokens. It is also universally supported across all current Proxmox products. Unless SSH is specifically required, it is advised to use the HTTPS backend. Installing Dependencies \u00b6 In addition to installing the proxmoxer package via pip, the following packages are required for each backend. https openssh ssh_paramiko pip install requests If you will be uploading files, installing requests_toolbelt will automatically allow larger upload file sizes and reduce memory footprint of an upload pip install openssh_wrapper pip install paramiko You can, of course, install all the dependencies with pip install requests requests_toolbelt openssh_wrapper paramiko to be able to use any of the backends.","title":"Setup"},{"location":"setup/#setup","text":"Proxmoxer is easy to setup and has minimal dependencies.","title":"Setup"},{"location":"setup/#choosing-a-backend","text":"The required dependencies change depending on the backend (connection method) you will use. The HTTPS backend better matches the details in the Proxmox API documentation, but SSH can be used in an (mostly) interchangeable manner. SSH can be used with complex network environments and can be used with jump hosts. The HTTPS backend can be used through a reverse proxy or any other HTTPS manipulation scheme. For most users, the HTTPS backend will be suitable. The HTTPS backend allows connections for non-PAM realm accounts and supports advanced authentication methods such as API Tokens. It is also universally supported across all current Proxmox products. Unless SSH is specifically required, it is advised to use the HTTPS backend.","title":"Choosing a Backend"},{"location":"setup/#installing-dependencies","text":"In addition to installing the proxmoxer package via pip, the following packages are required for each backend. https openssh ssh_paramiko pip install requests If you will be uploading files, installing requests_toolbelt will automatically allow larger upload file sizes and reduce memory footprint of an upload pip install openssh_wrapper pip install paramiko You can, of course, install all the dependencies with pip install requests requests_toolbelt openssh_wrapper paramiko to be able to use any of the backends.","title":"Installing Dependencies"},{"location":"examples/files/","text":"Files \u00b6 Uploading Files to PVE \u00b6 If you have files on your device which you want to upload to your PVE, it is easy to do. First, to upload large file and to prevent high memory usage, install the requests_toolbelt pip package ( pip install requests_toolbelt ). Next, you will need to open the file you want to upload. f = open(\"<file_path>\", \"rb\") Finally, upload the file specifying the correct content type (\"template\" or \"iso\"). prox.proxmox.nodes('<node_name>').storage('<storage_name>').upload.post(content='<content_type>', filename=f) Downloading Files to PVE \u00b6 An alternative to downloading a file to your computer and then uploading it to your PVE instance, you can request PVE directly download the file from its URL. Assuming prox is a valid ProxmoxerAPI object and sourceURL is a complete URL of a file to download. content is the same options as above and filename is the name the file will be saved as on the PVE storage. proxmox.nodes(\"<node_name>\").storage(\"<storage_name>\")(\"download-url\").post(url=sourceURL, content=\"<content_type>\", filename=\"<file_name.extension>\") To ensure the file downloaded is the file you expect, you can also specify a hash and algorithm which PVE will check against the file it downloads. proxmox.nodes(\"<node_name>\").storage(\"<storage_name>\")(\"download-url\").post(url=sourceURL, content=\"<content_type>\", filename=\"<file_name.extension>\", checksum=\"<hash>\", \"checksum-algorithm\": \"<md5 | sha1 | sha224 | sha256 | sha384 | sha512>\") This post request will return the UPID of the task created for that download. To wait (block) until a download is complete, see the Blocking Until Task is Complete section.","title":"Sending Files"},{"location":"examples/files/#files","text":"","title":"Files"},{"location":"examples/files/#uploading-files-to-pve","text":"If you have files on your device which you want to upload to your PVE, it is easy to do. First, to upload large file and to prevent high memory usage, install the requests_toolbelt pip package ( pip install requests_toolbelt ). Next, you will need to open the file you want to upload. f = open(\"<file_path>\", \"rb\") Finally, upload the file specifying the correct content type (\"template\" or \"iso\"). prox.proxmox.nodes('<node_name>').storage('<storage_name>').upload.post(content='<content_type>', filename=f)","title":"Uploading Files to PVE"},{"location":"examples/files/#downloading-files-to-pve","text":"An alternative to downloading a file to your computer and then uploading it to your PVE instance, you can request PVE directly download the file from its URL. Assuming prox is a valid ProxmoxerAPI object and sourceURL is a complete URL of a file to download. content is the same options as above and filename is the name the file will be saved as on the PVE storage. proxmox.nodes(\"<node_name>\").storage(\"<storage_name>\")(\"download-url\").post(url=sourceURL, content=\"<content_type>\", filename=\"<file_name.extension>\") To ensure the file downloaded is the file you expect, you can also specify a hash and algorithm which PVE will check against the file it downloads. proxmox.nodes(\"<node_name>\").storage(\"<storage_name>\")(\"download-url\").post(url=sourceURL, content=\"<content_type>\", filename=\"<file_name.extension>\", checksum=\"<hash>\", \"checksum-algorithm\": \"<md5 | sha1 | sha224 | sha256 | sha384 | sha512>\") This post request will return the UPID of the task created for that download. To wait (block) until a download is complete, see the Blocking Until Task is Complete section.","title":"Downloading Files to PVE"},{"location":"examples/tasks/","text":"Tasks \u00b6 Basic Task Interaction \u00b6 What is a task UPID? \u00b6 Most actions on Proxmox services are backed by tasks. These are visible in the web UI and are created when automation or users request actions be completed. Tasks are uniquely identified by a UPID which follows the format UPID:<node_name>:<pid_in_hex>:<pstart_in_hex>:<starttime_in_hex>:<type>:<id (optional)>:<user>@<realm>: For example UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam: or UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam: . Getting Task IDs \u00b6 The Proxmoxer service instance will maintain a record of all past tasks as well as all currently active tasks. The list of these tasks can be requested. >>> prox.nodes(\"mini-pve-0\").tasks.get(limit=3, source=\"all\") [{'id': '103', 'user': 'root@pam', 'pstart': 65597267, 'saved': '0', 'type': 'vzdump', 'pid': 851962, 'upid': 'UPID:mini-pve-0:000CFFFA:03E8EF53:619480BA:vzdump:103:root@pam:', 'node': 'mini-pve-0', 'starttime': 1637122234, 'status': 'RUNNING'}, {'user': 'root@pam', 'endtime': 1637122161, 'id': '', 'upid': 'UPID:mini-pve-0:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'node': 'mini-pve-0', 'starttime': 1637122156, 'status': 'OK', 'type': 'aptupdate', 'pid': 851036, 'pstart': 65589443}, {'endtime': 1637121960, 'id': '', 'user': 'root@pam', 'pstart': 65550050, 'pid': 848306, 'type': 'vncshell', 'starttime': 1637121762, 'upid': 'UPID:mini-pve-0:000CF1B2:03E836E2:61947EE2:vncshell::root@pam:', 'node': 'mini-pve-0', 'status': 'OK'}] Additional filters can be found in the documentation . Getting Task Details \u00b6 Each task has associated information on the status of the task and a log of the output of the task. This data can be collected by using the UPID of the task. >>> prox.nodes(\"mini-pve-0\").tasks(\"UPID:mini-pve-0:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").status.get() {'pid': 851036, 'node': 'mini-pve-0', 'type': 'aptupdate', 'upid': 'UPID:mini-pve-0:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'status': 'stopped', 'starttime': 1637122156, 'pstart': 65589443, 'id': '', 'exitstatus': 'OK', 'user': 'root@pam'} >>> prox.nodes(\"mini-pve-0\").tasks(\"UPID:mini-pve-0:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").log.get() [{'n': 1, 't': 'starting apt-get update'}, {'t': 'Hit:1 http://ftp.us.debian.org/debian bullseye InRelease', 'n': 2}, {'n': 3, 't': 'Get:2 http://ftp.us.debian.org/debian bullseye-updates InRelease [39.4 kB]'}, {'t': 'Get:3 http://security.debian.org bullseye-security InRelease [44.1 kB]', 'n': 4}, {'n': 5, 't': 'Get:4 http://download.proxmox.com/debian/pve bullseye InRelease [3053 B]'}, {'t': 'Fetched 86.5 kB in 1s (125 kB/s)', 'n': 6}, {'t': 'Reading package lists...', 'n': 7}, {'t': 'TASK OK', 'n': 8}] The status information (for completed tasks) includes information on who, when, where, and what was done in that task. The log contains a list of dicts which are {'n': <int_of_line_number>, 't': '<line_text>'} , one for each line of output. Tasks in Progress \u00b6 While tasks are active, the status endpoint returns information on the setup and start of the task and a status or \"running\". Blocking Until Task is Complete \u00b6 Many API endpoints will return a task UPID while the task completes in the background. While this can be useful to allow asynchronous execution, often you may desire to wait (block) for a task to finish. The code below provides a (very) basic way of polling the API until the task completes. def basic_blocking_task_status(proxmox_api, task_id, node_name): data = {\"status\": \"\"} while (data[\"status\"] != \"stopped\"): data = proxmox_api.nodes(node_name).tasks(task_id).status.get() return data","title":"Tasks"},{"location":"examples/tasks/#tasks","text":"","title":"Tasks"},{"location":"examples/tasks/#basic-task-interaction","text":"","title":"Basic Task Interaction"},{"location":"examples/tasks/#what-is-a-task-upid","text":"Most actions on Proxmox services are backed by tasks. These are visible in the web UI and are created when automation or users request actions be completed. Tasks are uniquely identified by a UPID which follows the format UPID:<node_name>:<pid_in_hex>:<pstart_in_hex>:<starttime_in_hex>:<type>:<id (optional)>:<user>@<realm>: For example UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam: or UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam: .","title":"What is a task UPID?"},{"location":"examples/tasks/#getting-task-ids","text":"The Proxmoxer service instance will maintain a record of all past tasks as well as all currently active tasks. The list of these tasks can be requested. >>> prox.nodes(\"mini-pve-0\").tasks.get(limit=3, source=\"all\") [{'id': '103', 'user': 'root@pam', 'pstart': 65597267, 'saved': '0', 'type': 'vzdump', 'pid': 851962, 'upid': 'UPID:mini-pve-0:000CFFFA:03E8EF53:619480BA:vzdump:103:root@pam:', 'node': 'mini-pve-0', 'starttime': 1637122234, 'status': 'RUNNING'}, {'user': 'root@pam', 'endtime': 1637122161, 'id': '', 'upid': 'UPID:mini-pve-0:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'node': 'mini-pve-0', 'starttime': 1637122156, 'status': 'OK', 'type': 'aptupdate', 'pid': 851036, 'pstart': 65589443}, {'endtime': 1637121960, 'id': '', 'user': 'root@pam', 'pstart': 65550050, 'pid': 848306, 'type': 'vncshell', 'starttime': 1637121762, 'upid': 'UPID:mini-pve-0:000CF1B2:03E836E2:61947EE2:vncshell::root@pam:', 'node': 'mini-pve-0', 'status': 'OK'}] Additional filters can be found in the documentation .","title":"Getting Task IDs"},{"location":"examples/tasks/#getting-task-details","text":"Each task has associated information on the status of the task and a log of the output of the task. This data can be collected by using the UPID of the task. >>> prox.nodes(\"mini-pve-0\").tasks(\"UPID:mini-pve-0:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").status.get() {'pid': 851036, 'node': 'mini-pve-0', 'type': 'aptupdate', 'upid': 'UPID:mini-pve-0:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'status': 'stopped', 'starttime': 1637122156, 'pstart': 65589443, 'id': '', 'exitstatus': 'OK', 'user': 'root@pam'} >>> prox.nodes(\"mini-pve-0\").tasks(\"UPID:mini-pve-0:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").log.get() [{'n': 1, 't': 'starting apt-get update'}, {'t': 'Hit:1 http://ftp.us.debian.org/debian bullseye InRelease', 'n': 2}, {'n': 3, 't': 'Get:2 http://ftp.us.debian.org/debian bullseye-updates InRelease [39.4 kB]'}, {'t': 'Get:3 http://security.debian.org bullseye-security InRelease [44.1 kB]', 'n': 4}, {'n': 5, 't': 'Get:4 http://download.proxmox.com/debian/pve bullseye InRelease [3053 B]'}, {'t': 'Fetched 86.5 kB in 1s (125 kB/s)', 'n': 6}, {'t': 'Reading package lists...', 'n': 7}, {'t': 'TASK OK', 'n': 8}] The status information (for completed tasks) includes information on who, when, where, and what was done in that task. The log contains a list of dicts which are {'n': <int_of_line_number>, 't': '<line_text>'} , one for each line of output.","title":"Getting Task Details"},{"location":"examples/tasks/#tasks-in-progress","text":"While tasks are active, the status endpoint returns information on the setup and start of the task and a status or \"running\".","title":"Tasks in Progress"},{"location":"examples/tasks/#blocking-until-task-is-complete","text":"Many API endpoints will return a task UPID while the task completes in the background. While this can be useful to allow asynchronous execution, often you may desire to wait (block) for a task to finish. The code below provides a (very) basic way of polling the API until the task completes. def basic_blocking_task_status(proxmox_api, task_id, node_name): data = {\"status\": \"\"} while (data[\"status\"] != \"stopped\"): data = proxmox_api.nodes(node_name).tasks(task_id).status.get() return data","title":"Blocking Until Task is Complete"}]}